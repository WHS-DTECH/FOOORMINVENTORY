<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weekly Shopping List</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
  <nav class="navbar no-print">
    <div class="nav-left">
      <a href="/" class="nav-brand">üç≥ Food Room</a> |
      <a href="/recipes">Recipes</a> |
      <a href="/recbk">Recipe Book</a> |
      <a href="/class_ingredients">Class Ingredients</a> |
      <a href="/booking">Booking Calendar</a> |
      <a href="/shoplist">Shopping List</a>
      {% if current_user.is_admin() %}
        | <a href="/admin">Admin</a>
      {% endif %}
    </div>
    <div class="nav-right">
      {% if current_user.is_authenticated %}
        <span class="user-info">{{ current_user.name }}<span class="badge badge-{{ current_user.role }}">{{ current_user.role }}</span></span> | <a href="/logout" class="logout-link">Logout</a>
      {% else %}
        <a href="/login" class="login-link">Login</a>
      {% endif %}
    </div>
  </nav>

  <div class="week-nav no-print">
    <span class="label">{{ week_label }}</span>
    <a href="/shoplist?week={{ prev_week }}">Previous Week</a>
    {% if week_offset != 0 %}
    <a href="/shoplist?week=0" style="font-weight: bold;">Current Week</a>
    {% endif %}
    <a href="/shoplist?week={{ next_week }}">Next Week</a>
  </div>

  <div id="shoplist-actions-fixed" class="actions no-print shoplist-actions-top" style="margin-bottom: 18px; justify-content: flex-end; display: flex; gap: 8px; flex-wrap: wrap;">
    <button onclick="saveShoppingList()">üíæ Save List</button>
    <button onclick="loadShoppingList()">üìÇ Load Saved</button>
    <button onclick="exportShoppingListCsv()">üìÑ Export CSV</button>
    <button class="primary" onclick="window.print()">üñ®Ô∏è Print</button>
    <span style="flex: 1 1 auto;"></span>
    <button class="primary no-print" id="printListOnlyBtn" style="background: #28a745; margin-left: auto;" onclick="printShoppingListOnly()">üñ®Ô∏è Print Shopping List Only</button>
  </div>
    <style>
      body, html {
        font-family: Arial, Helvetica, sans-serif;
      }
      @media print {
        @page {
          size: A4 portrait;
          margin: 18mm 12mm 18mm 12mm;
        }
        html, body {
          margin: 0 !important;
          padding: 0 !important;
          font-family: Arial, Helvetica, sans-serif !important;
        }
        body.print-list-only * {
          visibility: hidden !important;
        }
        body.print-list-only .print-list-section, 
        body.print-list-only .print-list-section * {
          visibility: visible !important;
          display: block !important;
          position: static !important;
          width: 100% !important;
          min-width: 0 !important;
          margin: 0 !important;
          padding: 0 !important;
          background: white !important;
          color: black !important;
        }
        /* Stack columns vertically for print to avoid page breaks in the middle of a flex row */
        body.print-list-only .print-list-section > div {
          display: block !important;
        }
        /* Hide checkboxes for print */
        body.print-list-only input[type="checkbox"] {
          display: none !important;
        }
        /* Print-only header */
        .print-header {
          display: block !important;
          text-align: center;
          margin-bottom: 18px;
        }
        /* Print date */
        .print-date {
          display: block !important;
          text-align: right;
          font-size: 12px;
          color: #444;
          margin-bottom: 8px;
        }
        /* Page numbers */
        body.print-list-only::after {
          content: "Page " counter(page);
          position: fixed;
          bottom: 8mm;
          right: 12mm;
          font-size: 12px;
          color: #444;
        }
        /* Table styling for print */
        .print-category-table {
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 18px;
        }
        .print-category-table th, .print-category-table td {
          border: 1px solid #bbb;
          padding: 4px 8px;
          font-size: 15px;
        }
        .print-category-table th {
          background: #f0f0f0;
        }
        .print-section-sep {
          border-top: 2px solid #333;
          margin: 18px 0 12px 0;
        }
      }
      /* Hide print-only header on screen */
      .print-header, .print-date { display: none; }
    </style>
  <h1 class="no-print">Weekly Booking Grid</h1>
  <table class="grid no-print">
    <thead>
      <tr>
        <th>Period</th>
        {% for d in dates %}
          <th>{{ d.day_name }}<br><span class="small-muted">{{ d.nz_date }}</span></th>
        {% endfor %}
      </tr>
    </thead>
    <tbody>
      {% for period in range(1,6) %}
        <tr>
          <td><span class="period">P{{ period }}</span></td>
          {% for d in dates %}
            {% set key = d.date + '_P' + period|string %}
            {% set booking = grid.get(key) %}
            <td>
              {% if booking %}
                <div class="booking" data-booking-id="{{ booking.id }}" onclick="toggleBooking({{ booking.id }})">
                  <div class="booking-title">{{ booking.recipe_name or '‚Äî' }}</div>
                  <div class="booking-meta">Class: {{ booking.class_code or '‚Äî' }}</div>
                  <div class="booking-meta">Teacher: {{ booking.last_name or booking.staff_code or '‚Äî' }}{% if booking.first_name %}, {{ booking.first_name }}{% endif %}</div>
                  <div class="booking-meta">Servings: {{ booking.desired_servings or '‚Äî' }}</div>
                  <div class="booking-meta">{{ d.nz_date }}</div>
                  <div class="booking-meta">Tap to select</div>
                </div>
              {% else %}
                <div class="empty">‚Äî</div>
              {% endif %}
            </td>
          {% endfor %}
        </tr>
      {% endfor %}
    </tbody>
  </table>

  <div class="bottom-layout">
    <div class="panel no-print selected-bookings-popout">
      <h3>Selected Bookings</h3>
      <div class="actions" style="margin-bottom: 12px;">
        <button class="primary" onclick="autoGenerateWeek()" style="background: #28a745;">üöÄ Auto-Generate Week</button>
        <button onclick="selectAllWeek()">Select Entire Week</button>
        <button onclick="clearAllSelections()">Clear Selection</button>
        <button class="primary btn-generate-list" onclick="generateShoppingList()">Generate Shopping List</button>
      </div>
      <ul class="selected-list" id="selectedList"></ul>
      <div class="notice" id="selectionNotice">No bookings selected. Tap cells above or use "Auto-Generate Week".</div>
    </div>

    <div class="shopping-list print-list-section" id="shoppingList">
      <div class="print-header">
        <img src="{{ url_for('static', filename='images/whs logo circular reo .png') }}" alt="School Logo" class="print-logo">
        <div style="font-size: 2em; font-weight: bold; margin-bottom: 4px;">School Food Room Shopping List</div>
        <div style="font-size: 1.1em;">{{ week_label }}</div>
      </div>
      <div class="print-date" id="printDate"></div>
      <h2>Shopping List</h2>
      <div class="week-label">{{ week_label }}</div>
      <div id="listContent" class="small-muted">Click "Auto-Generate Week" to instantly create a shopping list for all bookings this week.</div>
    </div>
  </div>

  <div class="preview-banner no-print" style="margin-top: 12px;">Buttons and grid will not appear when printing; only the shopping list is printed.</div>

  <script>
    function printShoppingListOnly() {
      document.body.classList.add('print-list-only');
      // Wait for DOM to update and reflow before printing
      <style>
        body, html {
          font-family: Arial, Helvetica, sans-serif;
        }
        @media print {
          @page {
            size: A4 portrait;
            margin: 16mm 10mm 16mm 10mm;
          }
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            font-family: Arial, Helvetica, sans-serif !important;
            font-size: 16px !important;
          }
          body.print-list-only * {
            visibility: hidden !important;
          }
          body.print-list-only .print-list-section, 
          body.print-list-only .print-list-section * {
            visibility: visible !important;
            display: block !important;
            position: static !important;
            width: 100% !important;
            min-width: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            background: white !important;
            color: black !important;
          }
          /* Stack columns vertically for print to avoid page breaks in the middle of a flex row */
          body.print-list-only .print-list-section > div {
            display: block !important;
          }
          /* Hide checkboxes and Have? column for print */
          body.print-list-only input[type="checkbox"],
          body.print-list-only .print-category-table th.no-print,
          body.print-list-only .print-category-table td.no-print {
            display: none !important;
          }
          /* Print-only header */
          .print-header {
            display: block !important;
            text-align: center;
            margin-bottom: 18px;
          }
          /* Print logo always visible */
          .print-logo {
            display: block !important;
            margin: 0 auto 6px auto !important;
            height: 60px !important;
          }
          /* Print date */
          .print-date {
            display: block !important;
            text-align: right;
            font-size: 13px;
            color: #444;
            margin-bottom: 8px;
          }
          /* Page numbers */
          body.print-list-only::after {
            content: "Page " counter(page);
            position: fixed;
            bottom: 8mm;
            right: 12mm;
            font-size: 13px;
            color: #444;
          }
          /* Table styling for print */
          .print-category-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 18px;
          }
          .print-category-table th, .print-category-table td {
            border: 1px solid #bbb;
            padding: 2px 6px;
            font-size: 15px;
            line-height: 1.2;
          }
          .print-category-table th {
            background: #f0f0f0;
          }
          .print-section-sep {
            border-top: 2px solid #333;
            margin: 22px 0 16px 0;
          }
          .teacher-block {
            margin-bottom: 10px;
          }
        }
        /* Hide print-only header on screen */
        .print-header, .print-date { display: none; }
      </style>
        const parts = str.split('/');
        return parseInt(parts[0], 10) / parseInt(parts[1], 10);
      }
      // Handle numbers with Unicode fractions attached (no space): "24¬Ω"
      const unicodeFracMatch = str.match(/^(\d+(?:\.\d+)?)([¬Ω‚Öì‚Öî¬º¬æ‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû])$/);
      if (unicodeFracMatch) {
        const whole = parseFloat(unicodeFracMatch[1]);
        const frac = parseFraction(unicodeFracMatch[2]);
        return whole + frac;
      }
      // Handle "24 ¬Ω" or "24 2/3" with space
      const spacedFracMatch = str.match(/^(\d+(?:\.\d+)?)\s+([¬Ω‚Öì‚Öî¬º¬æ‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû]|\d+\/\d+)$/);
      if (spacedFracMatch) {
        const whole = parseFloat(spacedFracMatch[1]);
        const frac = parseFraction(spacedFracMatch[2]);
        return whole + frac;
      }
      const num = parseFloat(str.replace(',', '.'));
      return Number.isFinite(num) ? num : null;
    }

    function collapseDuplicateWords(str) {
      if (!str) return '';
      return str.replace(/\b(\w+)(\s+\1)+\b/gi, '$1');
    }

    function normalizeName(name) {
      if (!name) return '';
      let clean = name.toLowerCase().trim();
      clean = clean.replace(/\([^)]*\)/g, ''); // Remove parentheses
      clean = clean.replace(/\s+/g, ' '); // Collapse spaces
      clean = collapseDuplicateWords(clean);
      
      // Only apply pluralization normalization for exact matches to prevent incorrect merging
      const exactAliases = {
        'capsicums': 'capsicum',
        'peppers': 'pepper', 
        'tomatoes': 'tomato',
        'potatoes': 'potato',
        'onions': 'onion',
        'eggs': 'egg',
        'bananas': 'banana',
        'apples': 'apple'
      };
      
      // Only replace if the ENTIRE clean string matches
      if (exactAliases[clean]) {
        clean = exactAliases[clean];
      }
      
      return clean;
    }

    function formatQtyUnit(totalQty, unit) {
      if (totalQty === null || totalQty === undefined) return '';
      const u = normalizeUnit(unit);
      let qty = totalQty;
      
      // Convert large amounts to bigger units
      if (u === 'g' && qty >= 1000) {
        const kg = qty / 1000;
        return `${kg.toFixed(kg >= 10 ? 0 : kg >= 1 ? 1 : 2).replace(/\.0+$/, '')} kg`;
      }
      if (u === 'ml' && qty >= 1000) {
        const liters = qty / 1000;
        return `${liters.toFixed(liters >= 10 ? 0 : liters >= 1 ? 1 : 2).replace(/\.0+$/, '')} L`;
      }
      
      // Round whole numbers, show decimals for fractions
      if (qty === Math.floor(qty)) {
        return u ? `${qty} ${u}` : `${qty}`;
      }
      
      // Show up to 2 decimal places for fractional amounts
      const formatted = qty.toFixed(2).replace(/\.?0+$/, '');
      return u ? `${formatted} ${u}` : formatted;
    }

    function applyUnitlessHeuristic(name, unit) {
      if (unit) return unit;
      const base = normalizeName(name);
      if (produceUnitless.includes(base)) return 'pcs';
      // Common liquid/weight items that should have units
      const liquids = ['milk', 'water', 'oil', 'cream', 'juice'];
      const weighted = ['flour', 'sugar', 'butter', 'margarine', 'cheese', 'nuts', 'sultanas', 'carrots', 'oats'];
      if (liquids.includes(base)) return 'ml';
      if (weighted.includes(base)) return 'g';
      return '';
    }

    function convertToBase(qty, unit, ingredientName = '') {
      const u = normalizeUnit(unit);
      const nameLower = ingredientName.toLowerCase();
      
      // Check if this is a dry good that was incorrectly measured in volume
      const dryGoods = ['flour', 'sugar', 'oats', 'rice', 'salt', 'baking powder', 'baking soda',
                        'chocolate chips', 'chocolate', 'chips', 'wholemeal', 'white sugar', 'brown sugar'];
      const isDryGood = dryGoods.some(item => nameLower.includes(item));
      
      console.log(`convertToBase: qty=${qty}, unit=${unit}, name="${ingredientName}", isDryGood=${isDryGood}, normalized unit=${u}`);
      
      // Convert units to base units
      if (u === 'kg') return { qty: qty * 1000, unit: 'g' };
      if (u === 'g') return { qty, unit: 'g' };
      
      // For cups/teaspoons/tablespoons, convert dry goods to grams, liquids to ml
      if (u === 'cup') {
        if (isDryGood) {
          // 1 cup flour ‚âà 125g, 1 cup sugar ‚âà 200g, average ~150g for dry goods
          console.log(`  Converting ${qty} cup ${ingredientName} to ${qty * 150}g (dry good)`);
          return { qty: qty * 150, unit: 'g' };
        }
        return { qty: qty * 250, unit: 'ml' }; // Liquids: 1 cup = 250ml
      }
      
      if (u === 'tsp') {
        if (isDryGood) {
          // 1 tsp dry goods ‚âà 5g
          console.log(`  Converting ${qty} tsp ${ingredientName} to ${qty * 5}g (dry good)`);
          return { qty: qty * 5, unit: 'g' };
        }
        return { qty: qty * 5, unit: 'ml' }; // Liquids: 1 tsp = 5ml
      }
      
      if (u === 'tbsp') {
        if (isDryGood) {
          // 1 tbsp dry goods ‚âà 15g
          console.log(`  Converting ${qty} tbsp ${ingredientName} to ${qty * 15}g (dry good)`);
          return { qty: qty * 15, unit: 'g' };
        }
        return { qty: qty * 15, unit: 'ml' }; // Liquids: 1 tbsp = 15ml
      }
      
      // For liters/ml, check if it's a dry good first
      if (u === 'l') {
        if (isDryGood) {
          console.log(`  Converting ${qty}L ${ingredientName} to ${qty * 1000}g (dry good)`);
          return { qty: qty * 1000, unit: 'g' }; // Convert L to g for dry goods (1L ‚âà 1kg)
        }
        return { qty: qty * 1000, unit: 'ml' }; // Convert L to ml for liquids
      }
      if (u === 'ml') {
        if (isDryGood) {
          console.log(`  Converting ${qty}ml ${ingredientName} to ${qty}g (dry good)`);
          return { qty, unit: 'g' }; // Convert ml to g for dry goods (1ml ‚âà 1g)
        }
        return { qty, unit: 'ml' }; // Keep ml for liquids
      }
      
      // Default: return as-is
      // But if there's no unit and it's a dry good with a quantity, infer grams
      if (!u && qty && isDryGood && qty >= 10) {
        console.log(`  No unit for ${qty} ${ingredientName}, inferring grams (dry good)`);
        return { qty, unit: 'g' };
      }
      
      return { qty, unit: u };
    }

    function parseIngredient(raw) {
      let result = { qty: null, unit: '', name: '' };
      
      // The PDF parser stored data in wrong fields. Common patterns:
      // 1. Everything in ingredient: "¬Ω cup Wholemeal flour" with empty qty/unit
      // 2. Ingredient has "t baking powder", unit has "¬º", qty has "1.0"
      // 3. Ingredient has "Cup sugar", unit has "1/2", qty has "1.0"
      // 4. Ingredient has "or margarine", unit has "butter"
      
      let fullText = (raw.ingredient || '').trim();
      
      // If ingredient field contains fraction/number + unit + name pattern, parse from there
      // Match patterns like: "¬Ω cup Wholemeal flour", "2/3 Cup sugar", "1/2 t baking powder"
      const fullMatch = fullText.match(/^([¬Ω‚Öì‚Öî¬º¬æ‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû]|\d+\/\d+|\d+\s+\d+\/\d+|\d+(?:\.\d+)?)\s*([a-zA-Z]+)\s+(.+)$/i);
      
      if (fullMatch) {
        // Pattern matched: extract qty, unit, name from ingredient field
        result.qty = parseFraction(fullMatch[1]) || parseNumber(fullMatch[1]);
        result.unit = normalizeUnit(fullMatch[2]);
        result.name = fullMatch[3].trim();
      } else if (fullText.match(/^([¬Ω‚Öì‚Öî¬º¬æ‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû]|\d+\/\d+)\s+(.+)$/)) {
        // Just fraction + name (no unit word): "¬Ω Wholemeal flour"
        const fracMatch = fullText.match(/^([¬Ω‚Öì‚Öî¬º¬æ‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû]|\d+\/\d+)\s+(.+)$/);
        result.qty = parseFraction(fracMatch[1]);
        result.name = fracMatch[2].trim();
      } else {
        // Use the database fields as-is
        result.qty = parseNumber(raw.quantity);
        result.unit = normalizeUnit(raw.unit);
        result.name = fullText;
        
        // But if unit field contains a fraction, it's probably misplaced
        if (raw.unit && (raw.unit.match(/[¬Ω‚Öì‚Öî¬º¬æ]/) || raw.unit.match(/^\d+\/\d+$/))) {
          const fracQty = parseFraction(raw.unit);
          if (fracQty > 0) {
            // Multiply qty by the fraction in unit field
            result.qty = (result.qty || 1) * fracQty;
            result.unit = ''; // Clear the bogus unit
          }
        }
      }
      
      // Clean up the name
      let cleanName = result.name.trim();
      
      // Skip if this looks like concatenated ingredients (bad recipe data)
      // e.g., "butter 2 Ripe Banana" has a number mid-string
      if (/\s+\d+\s+[A-Z]/.test(cleanName)) {
        // Try to extract just the first ingredient before the number
        const match = cleanName.match(/^([^0-9]+?)(?=\s+\d)/);
        if (match) {
          cleanName = match[1].trim();
        }
      }
      
      // Handle fractions in the name field (if still there after initial parsing)
      // Match "t baking powder" where "t" should be extracted as unit
      const unitInName = cleanName.match(/^([a-z])\s+(.+)$/i);
      if (unitInName && !result.unit) {
        const potentialUnit = normalizeUnit(unitInName[1]);
        if (potentialUnit) {
          result.unit = potentialUnit;
          cleanName = unitInName[2].trim();
        }
      }
      
      // Match "Cup sugar" or "cup Milk" where unit is capitalized in name
      const capUnitInName = cleanName.match(/^(cup|tsp|tbsp|t)\s+(.+)$/i);
      if (capUnitInName && !result.unit) {
        result.unit = normalizeUnit(capUnitInName[1]);
        cleanName = capUnitInName[2].trim();
      }
      
      // Remove "or ..." alternatives - handle both "butter or margarine" and "or margarine"
      cleanName = cleanName.replace(/^or\s+/i, '').trim(); // Remove "or" at start
      cleanName = cleanName.replace(/\s+or\s+.*/i, '').trim(); // Remove " or ..." in middle
      
      // Strip instruction phrases from the name
      const instructionPatterns = [
        /[,‚Äì‚Äî-]\s*(beaten|mixed|chopped|diced|sliced|minced|crushed|grated|melted|softened|room temperature|cut into|finely|roughly|coarsely).*/gi,
        /\s+to taste$/i,
        /\s+optional$/i,
        /\s+if needed$/i,
        /\s+for serving$/i,
        /\s+for garnish$/i,
        /\s+\(.*?\)$/g
      ];
      
      instructionPatterns.forEach(pattern => {
        cleanName = cleanName.replace(pattern, '');
      });
      
      // Skip if it's purely instructional text or empty
      const skipPatterns = [/don't/i, /forget/i, /container/i, /take/i, /head of/i, /mix of/i, /^beaten/i, /^mixed/i, /^chopped/i, /^or$/i];
      if (skipPatterns.some(p => p.test(cleanName)) || !cleanName) {
        return { qty: 0, unit: '', name: '' };
      }
      
      result.name = cleanName;
      
      // Strip quantity/unit prefix from name if qty/unit already provided
      // e.g., "360 ml cup Milk" with qty=360, unit=ml should become just "Milk"
      // Also handle single-letter units like "t" for teaspoon
      if (result.qty && result.unit) {
        // Remove leading number + unit pattern from name (including single-letter units)
        result.name = result.name.replace(/^\d+(?:\.\d+)?\s*(?:g|kg|ml|l|tsp|t|tbsp|tbs|cup|c)\s+/i, '').trim();
      }
      
      // Always try to strip quantity/unit prefix from name for unparsed cases
      const m = result.name.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z]+)\s+(.+)/);
      if (m) {
        const potentialQty = parseNumber(m[1]);
        const potentialUnit = normalizeUnit(m[2]);
        const restOfName = m[3];
        
        // Only use extracted values if qty wasn't already set
        if (!result.qty && potentialQty) {
          result.qty = potentialQty;
        }
        
        // Only set unit if it wasn't already set AND the extracted unit looks valid
        if (!result.unit && potentialUnit) {
          result.unit = potentialUnit;
        }
        
        // Always use the rest of the name (without the prefix)
        result.name = restOfName;
      }
      
      // Fix wrong unit assignments (flour in liters, etc.)
      if (result.unit === 'l' || result.unit === 'ml') {
        const dryGoods = ['flour', 'sugar', 'oats', 'rice', 'salt', 'baking powder', 'baking soda', 
                          'chocolate chips', 'chocolate', 'chips', 'wholemeal', 'white sugar', 'brown sugar'];
        if (dryGoods.some(item => result.name.toLowerCase().includes(item))) {
          // Convert ml/l to grams (assuming 1ml = 1g for dry goods approximation)
          if (result.unit === 'l') {
            result.qty = result.qty * 1000;
            result.unit = 'g';
          } else if (result.unit === 'ml') {
            result.unit = 'g';
          }
        }
      }
      
      // If we have a quantity but no unit, try to infer it
      if (result.qty && !result.unit) {
        // Check if the quantity suggests grams (typically 50+)
        if (result.qty >= 50 && result.qty <= 10000) {
          const weightItems = ['butter', 'margarine', 'flour', 'sugar', 'cheese', 'chocolate', 'nuts', 
                                'rice', 'pasta', 'oats', 'sultanas', 'chocolate chips', 'white sugar', 'brown sugar'];
          if (weightItems.some(item => result.name.toLowerCase().includes(item))) {
            result.unit = 'g';
          }
        }
        // Check for liquids
        const liquidItems = ['milk', 'water', 'oil', 'cream', 'juice', 'stock', 'broth', 'vinegar'];
        if (liquidItems.some(item => result.name.toLowerCase().includes(item))) {
          result.unit = result.qty >= 50 ? 'ml' : 'tbsp';
        }
      }
      
      result.unit = applyUnitlessHeuristic(result.name, result.unit);
      result.name = collapseDuplicateWords(result.name.trim());
      
      return result;
    }

    function getTeacherLabel(b) {
      if (b.last_name) {
        return b.first_name ? `${b.last_name}, ${b.first_name}` : b.last_name;
      }
      return b.staff_code || 'Unknown teacher';
    }

    function updateSelectionDisplay() {
      const listEl = document.getElementById('selectedList');
      const notice = document.getElementById('selectionNotice');
      listEl.innerHTML = '';
      if (selection.size === 0) {
        notice.style.display = 'block';
        console.log('No bookings selected.');
        return;
      }
      notice.style.display = 'none';
      const selectedBookings = bookings.filter(b => selection.has(b.id)).sort((a, b) => {
        if (a.date_required === b.date_required) return a.period - b.period;
        return a.date_required.localeCompare(b.date_required);
      });
      console.log('Selected bookings:', selectedBookings);
      selectedBookings.forEach(b => {
        const li = document.createElement('li');
        const teacher = getTeacherLabel(b);
        const dateObj = dates.find(d => d.date === b.date_required);
        const day = dateObj ? `${dateObj.day_name} ${dateObj.nz_date}` : b.date_required;
        li.textContent = `${teacher} | ${b.class_code || ''} | ${b.recipe_name || ''} | P${b.period} | ${day} | servings ${b.desired_servings || '‚Äî'}`;
        listEl.appendChild(li);
      });
    }

    function toggleBooking(id) {
      console.log('toggleBooking called with id:', id);
      if (selection.has(id)) {
        selection.delete(id);
        console.log('Removed from selection:', id);
      } else {
        selection.add(id);
        console.log('Added to selection:', id);
      }
      document.querySelectorAll(`[data-booking-id]`).forEach(el => {
        const bid = parseInt(el.dataset.bookingId, 10);
        if (selection.has(bid)) {
          el.classList.add('selected');
        } else {
          el.classList.remove('selected');
        }
      });
      console.log('Current selection:', Array.from(selection));
      updateSelectionDisplay();
    }

    function selectAllWeek() {
      bookings.forEach(b => selection.add(b.id));
      document.querySelectorAll('[data-booking-id]').forEach(el => el.classList.add('selected'));
      updateSelectionDisplay();
    }

    function clearAllSelections() {
      selection.clear();
      document.querySelectorAll('[data-booking-id]').forEach(el => el.classList.remove('selected'));
      updateSelectionDisplay();
      document.getElementById('listContent').textContent = 'Generate the shopping list to see items here.';
    }

    function aggregateItems() {
      const ingredientMap = new Map();
      const teacherMap = new Map();

      selection.forEach(id => {
        const booking = bookings.find(b => b.id === id);
        if (!booking) return;
        const recipe = recipes[booking.recipe_id];
        if (!recipe || !Array.isArray(recipe.ingredients)) return;
        const baseServings = parseNumber(recipe.serving_size) || 1;
        const targetServings = parseNumber(booking.desired_servings) || baseServings;
        const scale = targetServings / baseServings;
        const teacherKey = getTeacherLabel(booking);
        if (!teacherMap.has(teacherKey)) teacherMap.set(teacherKey, new Map());
        const teacherItems = teacherMap.get(teacherKey);

        recipe.ingredients.forEach(rawIng => {
          const parsed = parseIngredient(rawIng);
          // Skip empty/instruction items
          if (!parsed.name || parsed.qty === 0) return;
          const qty = parsed.qty || 1;
          const scaledQty = qty * scale;
          const base = convertToBase(scaledQty, parsed.unit, parsed.name);
          const nameKey = normalizeName(parsed.name);
          const displayName = collapseDuplicateWords(parsed.name.trim()) || 'Item';
          const overallEntry = ingredientMap.get(nameKey) || { name: displayName, qty: 0, unit: base.unit };
          // Always use cleaned name
          overallEntry.name = displayName;
          if (overallEntry.unit && base.unit && overallEntry.unit === base.unit) {
            overallEntry.qty += base.qty;
          } else if (!overallEntry.unit) {
            overallEntry.qty += base.qty;
            overallEntry.unit = base.unit;
          } else {
            overallEntry.qty += base.qty;
          }
          ingredientMap.set(nameKey, overallEntry);

          const teacherEntry = teacherItems.get(nameKey) || { name: displayName, qty: 0, unit: base.unit };
          // Always use cleaned name
          teacherEntry.name = displayName;
          if (teacherEntry.unit && base.unit && teacherEntry.unit === base.unit) {
            teacherEntry.qty += base.qty;
          } else if (!teacherEntry.unit) {
            teacherEntry.qty += base.qty;
            teacherEntry.unit = base.unit;
          } else {
            teacherEntry.qty += base.qty;
          }
          teacherItems.set(nameKey, teacherEntry);
        });
      });

      return { ingredientMap, teacherMap };
    }

    async function toggleAlreadyHave(itemName, qty, unit) {
      try {
        const response = await fetch('/api/shopping-list/toggle-item', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            week_start: weekStart,
            ingredient_name: itemName,
            quantity: qty,
            unit: unit
          })
        });
        const data = await response.json();
        if (data.success) {
          if (data.already_have) {
            alreadyHaveItems.add(itemName);
          } else {
            alreadyHaveItems.delete(itemName);
          }
          renderShoppingList();
        }
      } catch (error) {
        console.error('Error toggling item:', error);
      }
    }

    async function loadAlreadyHaveStatus() {
      try {
        const response = await fetch('/api/shopping-list/get-status', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({week_start: weekStart})
        });
        const data = await response.json();
        Object.keys(data.items).forEach(name => alreadyHaveItems.add(name));
      } catch (error) {
        console.error('Error loading status:', error);
      }
    }

    function renderShoppingList() {
      const target = document.getElementById('listContent');
      target.innerHTML = '';
      if (selection.size === 0) {
        target.textContent = 'Select bookings then generate the shopping list.';
        return;
      }
      const { ingredientMap, teacherMap } = aggregateItems();
      const overall = Array.from(ingredientMap.values());

      // Group by category
      const categorized = {};
      overall.forEach(item => {
        const category = categorizeIngredient(item.name);
        if (!categorized[category]) categorized[category] = [];
        categorized[category].push(item);
      });

      // Sort categories and items within each category
      const categoryOrder = ['Produce', 'Meat & Seafood', 'Dairy', 'Frozen', 'Pantry', 'Beverages', 'Other'];
      const sortedCategories = categoryOrder.filter(cat => categorized[cat]);

      // Add summary stats
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'shopping-summary';
      const notHaveCount = overall.filter(item => !alreadyHaveItems.has(item.name)).length;
      summaryDiv.innerHTML = `
        <div style="background: #e7f3ff; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <strong>üìä Summary:</strong> ${overall.length} unique ingredients | ${notHaveCount} needed | ${alreadyHaveItems.size} already have
        </div>
      `;

      // Print date (for print only)
      const printDate = document.getElementById('printDate');
      if (printDate) {
        const now = new Date();
        printDate.textContent = `Printed on: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
      }

      // Category Table with grouped categories
      const categoryTable = document.createElement('table');
      categoryTable.className = 'print-category-table';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headRow.innerHTML = '<th>Category</th><th>Item</th><th>Qty/Unit</th><th class="no-print">Have?</th>';
      thead.appendChild(headRow);
      categoryTable.appendChild(thead);
      const tbody = document.createElement('tbody');
      sortedCategories.forEach(category => {
        const items = categorized[category].sort((a, b) => a.name.localeCompare(b.name));
        items.forEach((item, idx) => {
          const tr = document.createElement('tr');
          if (idx === 0) {
            tr.innerHTML = `<td rowspan="${items.length}" style="vertical-align: top; font-weight: bold;">${category}</td><td>${item.name}</td><td>${formatQtyUnit(item.qty, item.unit)}</td>`;
          } else {
            tr.innerHTML = `<td style="display:none"></td><td>${item.name}</td><td>${formatQtyUnit(item.qty, item.unit)}</td>`;
          }
          // Checkbox (screen only)
          const tdCheck = document.createElement('td');
          tdCheck.className = 'no-print';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = alreadyHaveItems.has(item.name);
          checkbox.onclick = () => toggleAlreadyHave(item.name, item.qty, item.unit);
          tdCheck.appendChild(checkbox);
          tr.appendChild(tdCheck);
          tbody.appendChild(tr);
        });
      });
      categoryTable.appendChild(tbody);

      // Section: By Teacher
      const sectionSep = document.createElement('div');
      sectionSep.className = 'print-section-sep';

      const teacherContainer = document.createElement('div');
      teacherContainer.style.marginTop = '18px';
      const teacherHeading = document.createElement('h3');
      teacherHeading.textContent = 'By Teacher';
      teacherContainer.appendChild(teacherHeading);
      const sortedTeachers = Array.from(teacherMap.keys()).sort((a, b) => a.localeCompare(b));
      sortedTeachers.forEach(t => {
        const block = document.createElement('div');
        block.className = 'teacher-block';
        const heading = document.createElement('div');
        heading.innerHTML = `<strong>${t}</strong>`;
        block.appendChild(heading);
        const list = document.createElement('ul');
        list.className = 'shopping-items';
        const entries = Array.from(teacherMap.get(t).values()).sort((a, b) => a.name.localeCompare(b.name));
        entries.forEach(item => {
          const li = document.createElement('li');
          li.textContent = `${formatQtyUnit(item.qty, item.unit)} ${item.name}`.trim();
          list.appendChild(li);
        });
        block.appendChild(list);
        teacherContainer.appendChild(block);
      });

      // Compose final layout
      target.appendChild(summaryDiv);
      target.appendChild(categoryTable);
      target.appendChild(sectionSep);
      target.appendChild(teacherContainer);
    }

    function generateShoppingList() {
      renderShoppingList();
    }

    function autoGenerateWeek() {
      selectAllWeek();
      generateShoppingList();
      // Scroll to shopping list
      document.getElementById('shoppingList').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function exportShoppingListCsv() {
      if (selection.size === 0) {
        alert('Select bookings first.');
        return;
      }
      const { ingredientMap, teacherMap } = aggregateItems();
      let csv = `Week,,${weekLabel}\n`;
      csv += '\nAll bookings\n';
      csv += 'Qty,Unit,Item\n';
      Array.from(ingredientMap.values()).sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
        csv += `${item.qty},${item.unit || ''},"${item.name}"\n`;
      });
      csv += '\nBy teacher\n';
      Array.from(teacherMap.keys()).sort((a,b) => a.localeCompare(b)).forEach(t => {
        csv += `"${t}"\n`;
        Array.from(teacherMap.get(t).values()).sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
          csv += `${item.qty},${item.unit || ''},"${item.name}"\n`;
        });
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'shopping_list.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function saveShoppingList() {
      if (selection.size === 0) {
        alert('Generate a shopping list first.');
        return;
      }
      
      const listName = prompt('Enter a name for this shopping list:', `Shopping List ${new Date().toLocaleDateString()}`);
      if (!listName) return;
      
      const { ingredientMap } = aggregateItems();
      const items = Array.from(ingredientMap.values()).map(item => ({
        name: item.name,
        quantity: item.qty,
        unit: item.unit,
        category: categorizeIngredient(item.name)
      }));
      
      try {
        const response = await fetch('/api/shopping-list/save', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            list_name: listName,
            week_label: weekLabel,
            items: items
          })
        });
        const data = await response.json();
        if (data.success) {
          alert(`Shopping list "${listName}" saved successfully!`);
        }
      } catch (error) {
        console.error('Error saving list:', error);
        alert('Failed to save shopping list');
      }
    }

    async function loadShoppingList() {
      try {
        const response = await fetch('/api/shopping-list/saved');
        const data = await response.json();
        
        if (!data.lists || data.lists.length === 0) {
          alert('No saved shopping lists found.');
          return;
        }
        
        let listHTML = '<h3>Select a saved shopping list:</h3><ul style="list-style: none; padding: 0;">';
        data.lists.forEach(list => {
          const date = new Date(list.created_at).toLocaleDateString();
          listHTML += `<li style="padding: 8px; margin: 4px 0; border: 1px solid #ddd; cursor: pointer;" onclick="loadListById(${list.id})">
            <strong>${list.list_name}</strong><br>
            <small>${list.week_label || ''} - Created: ${date}</small>
          </li>`;
        });
        listHTML += '</ul>';
        
        const modal = document.createElement('div');
        modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;';
        modal.innerHTML = `<div style="background: white; padding: 20px; border-radius: 8px; max-width: 500px; max-height: 80vh; overflow-y: auto;">
          ${listHTML}
          <button onclick="this.closest('div').parentElement.remove()" style="margin-top: 12px;">Close</button>
        </div>`;
        document.body.appendChild(modal);
      } catch (error) {
        console.error('Error loading lists:', error);
        alert('Failed to load saved lists');
      }
    }

    async function loadListById(listId) {
      try {
        const response = await fetch(`/api/shopping-list/load/${listId}`);
        const data = await response.json();
        
        if (data.items) {
          const target = document.getElementById('listContent');
          target.innerHTML = '';
          
          const wrapper = document.createElement('div');
          const title = document.createElement('h3');
          title.textContent = data.list_name;
          wrapper.appendChild(title);
          
          if (data.week_label) {
            const weekInfo = document.createElement('p');
            weekInfo.textContent = data.week_label;
            weekInfo.style.cssText = 'color: #666; font-style: italic;';
            wrapper.appendChild(weekInfo);
          }
          
          // Group by category
          const categorized = {};
          data.items.forEach(item => {
            const category = item.category || categorizeIngredient(item.name);
            if (!categorized[category]) categorized[category] = [];
            categorized[category].push(item);
          });
          
          const categoryOrder = ['Produce', 'Meat & Seafood', 'Dairy', 'Frozen', 'Pantry', 'Beverages', 'Other'];
          categoryOrder.filter(cat => categorized[cat]).forEach(category => {
            const categoryDiv = document.createElement('div');
            categoryDiv.style.cssText = 'margin-bottom: 20px; border-left: 4px solid #0066cc; padding-left: 12px;';
            
            const categoryTitle = document.createElement('h4');
            categoryTitle.textContent = category;
            categoryTitle.style.cssText = 'margin: 8px 0; color: #0066cc;';
            categoryDiv.appendChild(categoryTitle);
            
            const list = document.createElement('ul');
            list.className = 'shopping-items';
            
            categorized[category].forEach(item => {
              const li = document.createElement('li');
              li.textContent = `${formatQtyUnit(item.quantity, item.unit)} ${item.name}`.trim();
              list.appendChild(li);
            });
            
            categoryDiv.appendChild(list);
            wrapper.appendChild(categoryDiv);
          });
          
          target.appendChild(wrapper);
          document.querySelector('[style*="rgba(0,0,0,0.5)"]')?.remove();
        }
      } catch (error) {
        console.error('Error loading list:', error);
        alert('Failed to load shopping list');
      }
    }


    // Expose selection functions globally for inline onclick handlers (do this at the top of the script)
    window.toggleBooking = function(){};
    window.selectAllWeek = function(){};
    window.clearAllSelections = function(){};
    window.generateShoppingList = function(){};
    window.autoGenerateWeek = function(){};
    window.exportShoppingListCsv = function(){};
    window.saveShoppingList = function(){};
    window.loadShoppingList = function(){};
    window.loadListById = function(){};

    // After all functions are defined, re-assign the real ones
    document.addEventListener('DOMContentLoaded', () => {
      window.toggleBooking = toggleBooking;
      window.selectAllWeek = selectAllWeek;
      window.clearAllSelections = clearAllSelections;
      window.generateShoppingList = generateShoppingList;
      window.autoGenerateWeek = autoGenerateWeek;
      window.exportShoppingListCsv = exportShoppingListCsv;
      window.saveShoppingList = saveShoppingList;
      window.loadShoppingList = loadShoppingList;
      window.loadListById = loadListById;
      updateSelectionDisplay();
      loadAlreadyHaveStatus();
    });

    document.addEventListener('DOMContentLoaded', () => {
      updateSelectionDisplay();
      loadAlreadyHaveStatus();
    });
  </script>
</body>
</html>
